#!/bin/bash

# DuckDuckGo: ffmpeg curve average brightness contrast decrease
# https://video.stackexchange.com/questions/20962/ffmpeg-color-correction-gamma-brightness-and-saturation
# https://ayosec.github.io/ffmpeg-filters-docs/3.0.12/Filters/Video/curves.html
# https://hhsprings.bitbucket.io/docs/programming/examples/ffmpeg/manipulating_video_colors/curves.html

# Initially generated by Claude to increase the brightness and modified by Grok to do the opposite.
# Further modified by Qwen3-Coder (480B parameters, 35B activated; 62 layers; 96 attention heads (Q), 8 (KV)).

# Further modified to output Avid DNxHR MXF format.

echo "Type the filename with extension: (Press TAB to autocomplete.) $1"
filename=$1
echo "filename: \"$filename\"" # Added quotes around $filename in the echo statement to handle filenames with spaces.

if [ -z "$filename" ]; then # The -z flag checks if the variable is empty, which is a more appropriate check for the purpose of this script.
  echo "No filename. The program will Exit!"
  sleep 1
  exit
fi

# Function to detect scan type using mediainfo
detect_scan_type() {
    local input_file="$1"
    # Pass the command "mediainfo --Inform='Video;%ScanType%' <input_video>" to the machine's terminal
    mediainfo --Inform='Video;%ScanType%' "$input_file"
}

# Function to get frame rate using mediainfo
get_frame_rate() {
    local input_file="$1"
    # Pass the command "mediainfo --Inform='Video;%FrameRate%' <input_video>" to the machine's terminal
    mediainfo --Inform='Video;%FrameRate%' "$input_file"
}

# Get video properties
scan_type=$(detect_scan_type "$filename")
frame_rate=$(get_frame_rate "$filename")

echo "Scan Type: $scan_type"
echo "Frame Rate: $frame_rate"

echo "This script will use FFmpeg's Curves filter to decrease video brightness. Example: -vf \"curves=all='0/0 0.5/0.3 1/1'\""
echo "The filter syntax is: curves=all='0/0 midpoint/brightness 1/1'"
echo "For example, '0/0 0.5/0.3 1/1' maps midtone brightness (0.5) to a lower brightness level (0.3)"
echo "Any value in the range of 0.1 to 1 can be used. Thus, any ratio, such as 0.5/0.2, 0.5/0.3, or 0.5/0.4, is possible."

read -p "Enter the brightness factor numerator (e.g., 0.5): " numerator
read -p "Enter the brightness factor denominator (e.g., 0.3): " denominator

# Determine if video is interlaced
if [[ "$scan_type" == "Interlaced" ]]; then
    # For interlaced video, add yadif and scale filters
    CURVES_FILTER="yadif=0:-1:1,scale=trunc(iw/2)*2:trunc(ih/2)*2,curves=all='0/0 $numerator/$denominator 1/1'"
else
    # For progressive video, just apply curves
    CURVES_FILTER="curves=all='0/0 $numerator/$denominator 1/1'"
fi

# Add format filter for DNxHR compatibility
CURVES_FILTER="$CURVES_FILTER,format=yuv422p"

echo "Previewing the video with adjusted brightness..."
# Note: Preview might not show exact DNxHR colors, but gives an idea
ffplay -vf "curves=all='0/0 $numerator/$denominator 1/1':plot=out.plt" "$filename"

echo "Generating brightness curve plot..."
gnuplot -e "set terminal png size 800,600; set output 'brightness_curve.png'" out.plt

# This command does the following:
# 1. `gnuplot`: Calls the gnuplot program
# 2. `-e`: Allows you to execute gnuplot commands directly from the command line
# 3. `"set terminal png; set output 'output.png'"`: These are the gnuplot commands to set the output terminal to PNG and specify the output file name
# 4. `out.plt`: This is your input gnuplot script file
# 5. If you need a different image format, you can replace 'png' with other formats like 'jpeg', 'gif', or 'svg'.
# 6. You can adjust the size of the output image by adding size parameters, like this:
# gnuplot -e "set terminal png size 800,600; set output 'output.png'" out.plt

# https://www.baeldung.com/linux/view-images-from-terminal
# Requires ImageMagick

# Display the generated plot if ImageMagick is installed
if command -v display &> /dev/null; then
    display brightness_curve.png
    # Clean up temporary files
    rm brightness_curve.png
    rm out.plt
else
    echo "ImageMagick's 'display' command not found."
fi

read -p "Do you want to save the processed video in Avid DNxHR MXF format? (y/n): " choice
if [[ "$choice" =~ ^[Yy]$ ]]; then
    echo "Processing and saving the video..."

    # Generate output filename with .mxf extension
    output_filename="${filename%.*}-dark.mxf"

    # Construct the full FFmpeg command
    # Uses DNxHR HQ profile, PCM audio, and sets the frame rate
    ffmpeg_cmd="ffmpeg -i \"$filename\" -c:v dnxhd -profile:v dnxhr_hq -filter:v \"$CURVES_FILTER\" -c:a pcm_s16le -r $frame_rate \"$output_filename\""

    echo "Running command: $ffmpeg_cmd"
    eval $ffmpeg_cmd
    
    if [ $? -eq 0 ]; then
        echo "Processed video saved as: $output_filename"
        
        # Optional: Replace original file
        read -p "Would you like the processed video to replace the original one? (y/n): " choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            # Check for trash-cli or use rm as fallback
            if command -v trash &> /dev/null; then
                trash "$filename"
            else
                echo "trash-cli not found, using rm instead."
                rm "$filename"
            fi
            mv "$output_filename" "$filename"
            echo "Original video replaced with processed video."
        else
            echo "The original video has been retained."
        fi
    else
        echo "Error occurred during video processing."
    fi
    echo "Script execution completed."
else
    echo "Video processing cancelled."
fi
